#!/usr/bin/python3
#+
# Example use of python_freetype: print a chart of all glyphs,
# and corresponding character codes, encoded by a specified font.
# Invoke this script as follows:
#
#     font_chart <fontspec> <outfile>
#
# where <fontspec> is the Fontconfig pattern string identifying the
# font to use, and <outfile> is the name to give to the output PNG
# file containing the generated chart.
#
# Also requires Qahirah <https://github.com/ldo/qahirah>.
#
# Copyright 2015 by Lawrence D'Oliveiro <ldo@geek-central.gen.nz>. This
# script is licensed CC0
# <https://creativecommons.org/publicdomain/zero/1.0/>; do with it
# what you will.
#-

import sys
import math
import qahirah as qah
from qahirah import \
    CAIRO, \
    Colour, \
    Vector
import freetype2 as freetype
FT = freetype.FT

from code_blocks import \
    CodeBlock, \
    code_blocks

def make_image_surface(from_bitmap) :
    "copies the contents of a freetype2.Bitmap object into an array and creates and" \
    " returns a qahirah.ImageSurface object wrapping it."
    if from_bitmap.pixel_mode == FT.PIXEL_MODE_MONO :
        cairo_format = CAIRO.FORMAT_A1
    elif from_bitmap.pixel_mode == FT.PIXEL_MODE_GRAY :
        cairo_format = CAIRO.FORMAT_A8
    else :
        raise NotImplementedError("unsupported bitmap format %d" % from_bitmap.pixel_mode)
    #end if
    stride = qah.ImageSurface.format_stride_for_width(cairo_format, from_bitmap.width)
    buf = from_bitmap.to_array(stride)
    return \
        qah.ImageSurface.create_for_array \
          (
            arr = buf,
            format = cairo_format,
            dimensions = (from_bitmap.width, from_bitmap.rows),
            stride = stride
          )
#end make_image_surface

#+
# Mainline
#-

if len(sys.argv) != 3 :
    raise RuntimeError("need two args, the Fontconfig pattern string and the output filename")
#end if
patternstr, outfilename = sys.argv[1:]
textsize = 48 # maybe make this user-specifiable later
nr_cols = 32
label_font_name = "serif" # something acceptable to toy font face API only for now
title_size = textsize
label_large_size = textsize * 0.7
label_small_size = 12

lib = freetype.Library()
if patternstr.find("/") >= 0 or any(patternstr.endswith(suffix) for suffix in (".otf", ".ttf")) :
    # interpret as filename
    show_face = lib.new_face(patternstr)
else :
    show_face = lib.find_face(patternstr)
#end if
sys.stderr.write("show font family %s style %s filename %s\n" % (show_face.family_name, show_face.style_name, show_face.filename)) # debug
show_face.set_char_size(size = textsize, resolution = freetype.base_dpi)
max_show_ascender = show_face.size["metrics"]["ascender"]
max_show_descender = - show_face.size["metrics"]["descender"]
max_show_advance = show_face.size["metrics"]["max_advance"]
g = qah.Context.create_for_dummy()
g.select_font_face(label_font_name, CAIRO.FONT_SLANT_NORMAL, CAIRO.FONT_WEIGHT_NORMAL)
g.set_font_size(title_size)
max_title_ascender = g.font_extents.ascent
max_title_descender = g.font_extents.descent
g.set_font_size(label_large_size)
max_label_large_ascender = g.font_extents.ascent
max_label_large_descender = g.font_extents.descent
g.set_font_size(label_small_size)
max_label_small_ascender = g.font_extents.ascent
max_label_small_descender = g.font_extents.descent
# sys.stderr.write("show ascender = %.3f, descender = %.3f, height = %.3f, max_advance = %.3f\n" % (max_show_ascender, max_show_descender, show_face.size["metrics"]["height"], max_show_advance)) # debug

nr_blocks = 0
nr_rows = 0
show_char_blocks = []
unmapped_glyphs = set(range(1, show_face.num_glyphs)) # always ignore glyph 0
last_end = 0
for code_block in code_blocks :
    if code_block.lo > last_end :
        check_blocks = [CodeBlock("Unassigned U+%X..U+%X" % (last_end, code_block.lo - 1), last_end, code_block.lo - 1), code_block]
          # make up an additional code block for the gap
    else :
        check_blocks = [code_block]
    #end if
    last_end = code_block.end
    for block in check_blocks :
        show_rows = set \
          (
            math.floor(c / nr_cols)
            for c in filter
              (
                lambda c : show_face.get_char_index(c) != 0, block.range
              )
          )
        unmapped_glyphs -= set(show_face.get_char_index(c) for c in block.range)
        if len(show_rows) != 0 :
            nr_blocks += 1
            show_block = \
                {
                    "name" : block.name,
                    "rows" : sorted(show_rows),
                    "lo" : block.lo,
                    "end" : block.end,
                }
            nr_rows += len(show_rows)
            show_char_blocks.append(show_block)
        #end if
    #end for
#end for
show_glyph_rows = list(sorted(set(math.floor(c / nr_cols) for c in unmapped_glyphs)))
if len(show_glyph_rows) != 0 :
    nr_rows += len(show_glyph_rows)
    nr_blocks += 1
#end if

pix_dimensions = \
    round \
      (
        Vector
          (
            x = nr_cols * max_show_advance,
            y =
                    max_title_ascender + max_title_descender
                +
                    nr_blocks * (max_label_large_ascender + max_label_large_descender)
                +
                        nr_rows
                    *
                        (
                            max_show_ascender
                        +
                            max_show_descender
                        +
                            max_label_small_ascender
                        +
                            max_label_small_descender
                        )
          )
      )
sys.stderr.write("creating image w×h = %d×%d\n" % (pix_dimensions.x, pix_dimensions.y)) # debug
pix = qah.ImageSurface.create \
  (
    format = CAIRO.FORMAT_RGB24,
    dimensions = pix_dimensions
  )
g = qah.Context.create(pix)
g.source_colour = Colour.grey(1)
g.operator = CAIRO.OPERATOR_SOURCE
g.paint()
g.source_colour = Colour.grey(0)
g.select_font_face(label_font_name, CAIRO.FONT_SLANT_NORMAL, CAIRO.FONT_WEIGHT_NORMAL)
g.set_font_size(title_size)
show_name = "%s %s" % (show_face.family_name, show_face.style_name)
g.move_to \
  ((
    (pix.width - g.text_extents(show_name)[2]) / 2, # horizontally centred
    max_title_ascender
  ))
g.show_text(show_name)
y = max_title_ascender + max_title_descender
for block in show_char_blocks :
    y += max_label_large_ascender
    g.set_font_size(label_large_size)
    g.move_to \
      ((
        (pix.width - g.text_extents(block["name"])[2]) / 2, # horizontally centred
        y
      ))
    g.show_text(block["name"])
    y += max_label_large_descender
    g.set_font_size(label_small_size)
    for row in block["rows"] :
        y += max_show_ascender
        x = 0
        for code in range(row * nr_cols, (row + 1) * nr_cols) :
            if code >= block["lo"] and code < block["end"] : # row might span more than one block
                glyph_code = show_face.get_char_index(code)
            else :
                glyph_code = 0
            #end if
            if glyph_code != 0 :
                try :
                    show_face.load_glyph(glyph_code, FT.LOAD_DEFAULT)
                except freetype.FTException as bad :
                    sys.stderr.write("bad glyph code %d for char U+%04X: %s\n" % (glyph_code, code, str(bad)))
                #end try
                if show_face.glyph.metrics["height"] != 0 : # will be 0 for empty glyph (e.g. space character)
                    show_face.glyph.render_glyph(FT.RENDER_MODE_NORMAL)
                    img = make_image_surface(show_face.glyph.bitmap)
                    g.mask_surface \
                      (
                        surface = img,
                        origin =
                          (
                            x + (max_show_advance - img.width) / 2,
                            y - show_face.glyph.metrics["horiBearingY"]
                          )
                      )
                #end if
                label = "U+%04X" % code
                g.move_to \
                  ((
                    x + (max_show_advance - g.text_extents(label)[2]) / 2,
                    y + max_show_descender + max_label_small_ascender
                  ))
                g.show_text(label)
            #end if
            x += max_show_advance
        #end for
        y += max_show_descender + max_label_small_ascender + max_label_small_descender
    #end for
#end for
if len(show_glyph_rows) != 0 :
    block_name = "Unmapped Glyphs"
    y += max_label_large_ascender
    g.set_font_size(label_large_size)
    g.move_to \
      ((
        (pix.width - g.text_extents(block_name)[2]) / 2, # horizontally centred
        y
      ))
    g.show_text(block_name)
    y += max_label_large_descender
    g.set_font_size(label_small_size)
    for row in show_glyph_rows :
        y += max_show_ascender
        x = 0
        for glyph_code in range(row * nr_cols, (row + 1) * nr_cols) :
            if glyph_code in unmapped_glyphs :
                try :
                    show_face.load_glyph(glyph_code, FT.LOAD_DEFAULT)
                except freetype.FTException as bad :
                    sys.stderr.write("bad glyph code %d: %s\n" % (glyph_code, str(bad)))
                #end try
                if show_face.glyph.metrics["height"] != 0 : # will be 0 for empty glyph (e.g. space character)
                    show_face.glyph.render_glyph(FT.RENDER_MODE_NORMAL)
                    img = make_image_surface(show_face.glyph.bitmap)
                    g.mask_surface \
                      (
                        surface = img,
                        origin =
                          (
                            x + (max_show_advance - img.width) / 2,
                            y - show_face.glyph.metrics["horiBearingY"]
                          )
                      )
                #end if
                label = "%#x" % glyph_code
                g.move_to \
                  ((
                    x + (max_show_advance - g.text_extents(label)[2]) / 2,
                    y + max_show_descender + max_label_small_ascender
                  ))
                g.show_text(label)
            #end if
            x += max_show_advance
        #end for
        y += max_show_descender + max_label_small_ascender + max_label_small_descender
    #end for
#end if
pix.flush()
sys.stderr.write("saving to %s..." % outfilename)
sys.stderr.flush()
pix.write_to_png(outfilename)
sys.stderr.write("done.\n")
