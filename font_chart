#!/usr/bin/python3
#+
# Example use of python_freetype: print a chart of all glyphs,
# and corresponding character codes, encoded by a specified font.
# Invoke this script as follows:
#
#     font_chart «fontspec» «outfile»
#
# where «fontspec» is the Fontconfig pattern string identifying the
# font to use, and «outfile» is the name to give to the output file
# containing the generated chart. The output can be PNG, with the
# whole chart on one page, or it can be PDF or PostScript, with
# each Unicode block on a separate page.
#
# Also requires Qahirah <https://github.com/ldo/qahirah>.
#
# Copyright 2015-2020 by Lawrence D'Oliveiro <ldo@geek-central.gen.nz>. This
# script is licensed CC0
# <https://creativecommons.org/publicdomain/zero/1.0/>; do with it
# what you will.
#-

import sys
import math
import getopt
import qahirah as qah
from qahirah import \
    CAIRO, \
    Colour, \
    Vector
import freetype2 as freetype
FT = freetype.FT
ft = qah.get_ft_lib() # might as well use same one

from code_blocks import \
    CodeBlock, \
    code_blocks

def make_image_surface(from_bitmap) :
    "copies the contents of a freetype2.Bitmap object into an array and creates and" \
    " returns a qahirah.ImageSurface object wrapping it."
    if from_bitmap.pixel_mode == FT.PIXEL_MODE_MONO :
        cairo_format = CAIRO.FORMAT_A1
    elif from_bitmap.pixel_mode == FT.PIXEL_MODE_GRAY :
        cairo_format = CAIRO.FORMAT_A8
    else :
        raise NotImplementedError("unsupported bitmap format %d" % from_bitmap.pixel_mode)
    #end if
    stride = qah.ImageSurface.format_stride_for_width(cairo_format, from_bitmap.width)
    buf = from_bitmap.to_array(stride)
    return \
        qah.ImageSurface.create_for_array \
          (
            arr = buf,
            format = cairo_format,
            dimensions = (from_bitmap.width, from_bitmap.rows),
            stride = stride
          )
#end make_image_surface

#+
# Mainline
#-

textsize = 48 # default
nr_cols = 32
show_glyph_codes = False
opts, args = getopt.getopt \
  (
    sys.argv[1:],
    "",
    ["cols=", "glyph-codes", "size="]
  )
for keyword, value in opts :
    if keyword == "--cols" :
        nr_cols = int(value)
    elif keyword == "--glyph-codes" :
        show_glyph_codes = True
    elif keyword == "--size" :
        textsize = float(value)
    #end if
#end for
if len(args) != 2 :
    raise getopt.GetoptError("need two args, the Fontconfig pattern string and the output filename")
#end if
patternstr, outfilename = args

if outfilename.endswith(".png") :
    multipage = False
elif outfilename.endswith(".pdf") :
    multipage = True
    MPSurface = qah.PDFSurface
elif outfilename.endswith(".ps") :
    multipage = True
    MPSurface = qah.PSSurface
else :
    raise getopt.GetoptError("output filename must end in .png, .pdf or .ps")
#end if

if patternstr.find("/") >= 0 or any(patternstr.endswith(suffix) for suffix in (".otf", ".ttf")) :
    # interpret as filename
    show_face = ft.new_face(patternstr)
else :
    show_face = ft.find_face(patternstr)
#end if
sys.stderr.write("show font family %s style %s filename %s\n" % (show_face.family_name, show_face.style_name, show_face.filename)) # debug
if len(show_face.available_sizes) != 0 :
    # fixme: quick hack for bitmap fonts
    sys.stderr.write("available_sizes = %s\n" % repr(show_face.available_sizes)) # debug
    use_size = show_face.available_sizes[0]
    show_face.set_pixel_sizes(use_size["x_ppem"], use_size["y_ppem"])
else :
    show_face.set_char_size(size = textsize, resolution = freetype.base_dpi)
#end if
max_show_ascender = show_face.size["metrics"]["ascender"]
max_show_descender = - show_face.size["metrics"]["descender"]
max_show_advance = show_face.size["metrics"]["max_advance"]

# get layout parameters for labels
label_font_name = "serif" # something acceptable to toy font face API only for now
title_size = textsize
label_large_size = textsize * 0.7
if show_glyph_codes :
    label_small_size = textsize / 6
else :
    label_small_size = textsize / 4
#end if
g = qah.Context.create_for_dummy()
g.select_font_face(label_font_name, CAIRO.FONT_SLANT_NORMAL, CAIRO.FONT_WEIGHT_NORMAL)
g.set_font_size(title_size)
max_title_ascender = g.font_extents.ascent
max_title_descender = g.font_extents.descent
g.set_font_size(label_large_size)
max_label_large_ascender = g.font_extents.ascent
max_label_large_descender = g.font_extents.descent
g.set_font_size(label_small_size)
max_label_small_ascender = g.font_extents.ascent
max_label_small_descender = g.font_extents.descent
# sys.stderr.write("show ascender = %.3f, descender = %.3f, height = %.3f, max_advance = %.3f\n" % (max_show_ascender, max_show_descender, show_face.size["metrics"]["height"], max_show_advance)) # debug

nr_blocks = 0
nr_rows = 0
show_char_blocks = []
unmapped_glyphs = set(range(1, show_face.num_glyphs)) # always ignore glyph 0
last_end = 0
for code_block in code_blocks :
    if code_block.lo > last_end :
        check_blocks = [CodeBlock("Unassigned U+%X..U+%X" % (last_end, code_block.lo - 1), last_end, code_block.lo - 1), code_block]
          # make up an additional code block for the gap
    else :
        check_blocks = [code_block]
    #end if
    last_end = code_block.end
    for block in check_blocks :
        show_rows = set \
          (
            math.floor(c / nr_cols)
            for c in filter
              (
                lambda c : show_face.get_char_index(c) != 0, block.range
              )
          )
          # set of row numbers having something to show on them
        unmapped_glyphs -= set(show_face.get_char_index(c) for c in block.range)
        if len(show_rows) != 0 :
            nr_blocks += 1
            show_block = \
                {
                    "name" : block.name,
                    "rows" : sorted(show_rows),
                    "lo" : block.lo,
                    "end" : block.end,
                }
            nr_rows += len(show_rows)
            show_char_blocks.append(show_block)
        #end if
    #end for
#end for
show_glyph_rows = list(sorted(set(math.floor(c / nr_cols) for c in unmapped_glyphs)))
if len(show_glyph_rows) != 0 :
    nr_rows += len(show_glyph_rows)
    nr_blocks += 1
#end if

chart_width = nr_cols * max_show_advance
chart_title_height = max_title_ascender + max_title_descender
chart_block_title_height = max_label_large_ascender + max_label_large_descender
chart_row_height = \
    max_show_ascender + max_show_descender + max_label_small_ascender + max_label_small_descender

if multipage :
    pix = MPSurface.create(outfilename, (0, 0))
else :
    pix_dimensions = \
        round \
          (
            Vector
              (
                x = chart_width,
                y =
                        chart_title_height
                    +
                        nr_blocks * chart_block_title_height
                    +
                        nr_rows * chart_row_height
              )
          )
    sys.stderr.write("creating image w×h = %d×%d\n" % (pix_dimensions.x, pix_dimensions.y)) # debug
    pix = qah.ImageSurface.create \
      (
        format = CAIRO.FORMAT_RGB24,
        dimensions = pix_dimensions
      )
#end if

done_title = False
g = y = None
def do_title(block) :
    global done_title, g, y
    if not done_title :
        g = qah.Context.create(pix)
    #end if
    if multipage :
        pix.set_size \
          (
            Vector
              (
                x = chart_width,
                y = chart_title_height + chart_block_title_height + len(block["rows"]) * chart_row_height
              )
          )
    #end if
    if multipage or not done_title :
        g.source_colour = Colour.grey(1)
        g.operator = CAIRO.OPERATOR_SOURCE
        g.paint()
        g.source_colour = Colour.grey(0)
        g.select_font_face(label_font_name, CAIRO.FONT_SLANT_NORMAL, CAIRO.FONT_WEIGHT_NORMAL)
        g.set_font_size(title_size)
        show_name = "%s %s" % (show_face.family_name, show_face.style_name)
        g.move_to \
          ((
            (chart_width - g.text_extents(show_name)[2]) / 2, # horizontally centred
            max_title_ascender
          ))
        g.show_text(show_name)
        y = max_title_ascender + max_title_descender
    #end if
    done_title = True
#end do_title

for block in show_char_blocks :
    do_title(block)
    y += max_label_large_ascender
    g.set_font_size(label_large_size)
    g.move_to \
      ((
        (chart_width - g.text_extents(block["name"])[2]) / 2, # horizontally centred
        y
      ))
    g.show_text(block["name"])
    y += max_label_large_descender
    g.set_font_size(label_small_size)
    for row in block["rows"] :
        y += max_show_ascender
        x = 0
        for code in range(row * nr_cols, (row + 1) * nr_cols) :
            if code >= block["lo"] and code < block["end"] : # row might span more than one block
                glyph_code = show_face.get_char_index(code)
            else :
                glyph_code = 0
            #end if
            if glyph_code != 0 :
                try :
                    show_face.load_glyph(glyph_code, FT.LOAD_DEFAULT)
                except freetype.FTException as bad :
                    sys.stderr.write("bad glyph code %d for char U+%04X: %s\n" % (glyph_code, code, str(bad)))
                #end try
                if show_face.glyph.metrics["height"] != 0 : # will be 0 for empty glyph (e.g. space character)
                    show_face.glyph.render_glyph(FT.RENDER_MODE_NORMAL)
                    img = make_image_surface(show_face.glyph.bitmap)
                    g.mask_surface \
                      (
                        surface = img,
                        origin =
                          (
                            x + (max_show_advance - img.width) / 2,
                            y - show_face.glyph.metrics["horiBearingY"]
                          )
                      )
                #end if
                label = "U+%0.4X" % code
                if show_glyph_codes :
                    label += " => %#0.4x" % glyph_code
                #end if
                g.move_to \
                  ((
                    x + (max_show_advance - g.text_extents(label)[2]) / 2,
                    y + max_show_descender + max_label_small_ascender
                  ))
                g.show_text(label)
            #end if
            x += max_show_advance
        #end for
        y += max_show_descender + max_label_small_ascender + max_label_small_descender
    #end for
    if multipage :
        pix.show_page()
    #end if
#end for
if len(show_glyph_rows) != 0 :
    do_title({"rows" : show_glyph_rows})
    block_name = "Unmapped Glyphs"
    y += max_label_large_ascender
    g.set_font_size(label_large_size)
    g.move_to \
      ((
        (chart_width - g.text_extents(block_name)[2]) / 2, # horizontally centred
        y
      ))
    g.show_text(block_name)
    y += max_label_large_descender
    g.set_font_size(label_small_size)
    for row in show_glyph_rows :
        y += max_show_ascender
        x = 0
        for glyph_code in range(row * nr_cols, (row + 1) * nr_cols) :
            if glyph_code in unmapped_glyphs :
                try :
                    show_face.load_glyph(glyph_code, FT.LOAD_DEFAULT)
                except freetype.FTException as bad :
                    sys.stderr.write("bad glyph code %d: %s\n" % (glyph_code, str(bad)))
                #end try
                if show_face.glyph.metrics["height"] != 0 : # will be 0 for empty glyph (e.g. space character)
                    show_face.glyph.render_glyph(FT.RENDER_MODE_NORMAL)
                    img = make_image_surface(show_face.glyph.bitmap)
                    g.mask_surface \
                      (
                        surface = img,
                        origin =
                          (
                            x + (max_show_advance - img.width) / 2,
                            y - show_face.glyph.metrics["horiBearingY"]
                          )
                      )
                #end if
                label = "%#x" % glyph_code
                g.move_to \
                  ((
                    x + (max_show_advance - g.text_extents(label)[2]) / 2,
                    y + max_show_descender + max_label_small_ascender
                  ))
                g.show_text(label)
            #end if
            x += max_show_advance
        #end for
        y += max_show_descender + max_label_small_ascender + max_label_small_descender
    #end for
    if multipage :
        pix.show_page()
    #end if
#end if
pix.flush()
if multipage :
    g = pix = None # no explicit flush call!
else :
    sys.stderr.write("saving to %s..." % outfilename)
    sys.stderr.flush()
    pix.write_to_png(outfilename)
#end if
sys.stderr.write("done.\n")
